# MIDI to buzzer music

This repository contains a few implementations for 1-bit music playback on buzzers or speakers,
targeting AVR microcontrollers.
A utility is also provided to convert from the MIDI file format to the format used by the
implementations.

The different implementations are:

- **ATmega328P, 2 channels / 1 buzzer**: uses Timer2 to generate a PWM with variable duty cycle,
  as well as Timer0 and Timer1 for the two channels. Supports 4 volume levels.
  Interrupts use roughly 1.5% CPU time at 10 MHz.

- **ATmega3208, 3 channels / 1 buzzer**: uses TCA0 high timer to generate a PWM with variable duty
  cycle, as well as TCB0, TCB1, and TCB2 for the three channels.  Supports 4 volume levels.
  Interrupts use roughly 0.5% CPU time at 16 MHz.

- **ATmega328P, 6 channels / 6 buzzers**: uses all three timers to drive the output of six separate
  buzzers, with two channels per timer. No volume support.
  Interrupts use roughly 2-3% CPU time at 16 MHz.


### How it works

The buzzer music formats store the tempo and track data. Each track is a list
of notes with their duration in 1/16th of a beat. There are also a few compression tricks used
but that's roughly it. The exact format is explained in details in `include/music.h`.

At a fixed internal which depends on the tempo, the main program advances each track by one note.
When a note changes, the corresponding timer period is updated. The timer period corresponds to
twice the note frequency since the output level changes twice per period.

For single buzzer implementations, each timer does not directly drive an output.
Instead, it updates the duty cycle of a PWM generated by another timer.
A buzzer acts as a low-pass filter, smoothing the fast PWM (60-200 kHz) into discrete levels,
effectively emulating a 2-bit DAC (or more if we consider volume).
When the phase of all notes are at their maximum, the duty cycle is maximal (100%), 
and inversely when the phase of all notes are at their minimum, the duty cycle is minimal (0%).


## Conversion utility

The conversion utility is located in the `utils/` directory. At the minimum, Python 3.7 is required.
Requirements can be installed with:
```shell
pip3 install -r requirements.txt
```
The program takes one input MIDI file and outputs data to a file or to stdout in binary format
or as a C header. Usage is as follows:
```shell
./midi_convert.py <input file> <output file> [options]
./midi_convert.py <input file> - [options] > output.dat
./midi_convert.py --help
```
The help message:
```text
usage: midi_convert.py [-h] [-l {off,error,warning,info}]
                       [-s {auto,opt_size,opt_channel,closest,closest_avg,first_fit_pref,first_fit,random}] [-t TEMPO]
                       [-r TIME_RANGE] [-c CHANNELS] [-m] [-x HEADER_NAME] [-o OCTAVE_ADJUST] [-w WAV_FILE]
                       input_file [output_file]

Convert MIDI file to buzzer music format

positional arguments:
  input_file            Input MIDI file
  output_file           Output buzzer music data (- for stdout)

optional arguments:
  -h, --help            show this help message and exit
  -l {off,error,warning,info}, --log {off,error,warning,info}
                        Log level (off | error | warning | info)
  -s {auto,opt_size,opt_channel,closest,closest_avg,first_fit_pref,first_fit,random}, --strategy {auto,opt_size,opt_channel,closest,closest_avg,first_fit_pref,first_fit,random}
                        Track note assignment strategy:
                        - auto: try strategies in order and use first that succeeds (default)
                        - opt_size: try all strategies and choose the smallest output size
                        - opt_channel: try all strategies and choose the smallest number of channels
                        - closest: assign notes to track currently playing closest note
                        - closest_avg: assign notes to track with the closest average note
                        - first_fit: assign note to first track that can play it
                        - first_fit_pref: like first_fit, priorizing tracks with a smaller range
                        - random: assign notes randomly to all available tracks
  -t TEMPO, --tempo TEMPO
                        Tempo override in BPM.
                        Note that this only affects the encoded tempo, not the actual tempo of the music.
  -r TIME_RANGE, --range TIME_RANGE
                        Time range to use from MIDI file, in seconds. Default is whole file.
                        - ':10': first 10 seconds
                        - '-10:': last 10 seconds
                        - '10:': all except first 10 seconds
                        - ':-10': all except last 10 seconds
                        - '10:-10': between first 10 s and last 10 s
  -c CHANNELS, --channels CHANNELS
                        Channel specification, using the following format:
                        '<lowest note>,<highest note>,<timer freq>;...'
                        The timer frequency is optional and only used for WAV file generation.
                        It indicates the timer interrupt frequency in Hz (<MCU freq> / <prescaler>).
                        Examples:
                        - 'B2,C#7,62500;-;C2,C8,250e3;-;B3,C8,125e3;-': ATmega328P 6 channels
                        - '0,72,5e6;-;-': ATmega3208 3 channels
                        These two specifications can also be set with 'atmega328p' and 'atmega3208' respectively.
                        Notes can be named (C2, C8) or numbered (0, 72).
                        The last channel specification can be duplicated using a - symbol.
                        Default is 'atmega3208'.
  -m, --merge-tracks    Merge MIDI tracks when creating buzzer tracks
  -x HEADER_NAME, --header HEADER_NAME
                        Name of array to output in xxd style C header (otherwise binary)
  -o OCTAVE_ADJUST, --octave OCTAVE_ADJUST
                        Octave adjustment for whole file
  -w WAV_FILE, --wav WAV_FILE
                        Output WAV file with simulated result.
                        To specify sample width append a ':n' parameter (default is 8-bit)
```
A WAV file can be output to get a preview of what the music will sound like the specified channels
configuration. The WAV can be either PWM (1-bit) or not (>1-bit).

Different "track strategies" can be used to get different assignment of notes onto tracks.
For implementations like on the ATmega328P where some timers have a narrower range than others,
some strategies will inevitably fail while other may succeed.
However, there can never be more notes played at once than there are channels specified, and
all notes must fall within the playable note range of at least one channel.
MIDI files may have to be modified in order for the conversion to work.

There is also a utility to do error analysis for a channel specification.
For example we can see with `utils/error_analysis.py atmega328p` that the
ATmega328P implementation has nearly 0.3 semitone error on some notes
(being limited by 8-bit timers).

### How it works

The conversion utility does the following:
- Read MIDI tracks (a list of events by MIDI time)
- Discard unused information (velocity, instruments, etc)
- Quantitize the data into the time frame used by the implementation (1/16th of a beat), 
  taking variable tempo into account.
- Do some adjustment (octave adjust, time range), and some verifications
  (max notes at once, note range).
- Assign each note to one channel using specified strategy 
  (or composite strategy, like optimizing for size).
- Encode the resulting tracks into buzzer music format.
- Generate the WAV file if needed.

## Building

Building is done with the provided Makefile. The target implementation must be specified
as an argument when invoking make:
```shell
export TARGET=atmega328p
make all
make upload
```
Other options may need to be changed when building, including the toolchain directory, 
the avrdude protocol, and the MCU clock frequency.

## License

All code is licensed under Apache License 2.0.

I do not own the rights to the music data committed in `include/music_data.h`.
